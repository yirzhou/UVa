# Random Problems

## Notes

- [2366]: Given a number `k` and a larger number `n`, if we want to divide `n` into as fewest pieces as possible with the smallest one as large as possible, there will be `p = ceil(n/k)` pieces, and the smallest piece will be `floor(n/p)`.
- [2213]: Require a Segment Tree with point update.
- [2040]: Binary search; 4 cases based on the sign: if `-ve` products `neg < k`, we directly count non-negative products `k-neg`; else, we swap `B1` and `B2` and count `neg-k+1`.
